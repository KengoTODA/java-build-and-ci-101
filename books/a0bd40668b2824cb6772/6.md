---
title: "継続的統合とは何で、なぜするのか"
---

前回までの章で、Gradleを使ったJavaプロジェクトのビルドについて学びました。
ビルドは常に手元の環境で行ってきましたが、もうひとつビルドの主要な用途として継続的統合（Continuous Integration）があります。

**継続的統合とはソフトウェアの公開プロセスを常に回し続けること、そのためにコードの変更をこまめにマージすること** です。
この章では継続的統合の生まれた背景と、その利点を解説します。

なおここでいうソフトウェア公開のことを、Gradle用語では `publish` と言いますし、Maven用語では `deploy` と言います。
ただ `deploy` は本番環境へ展開することを指すこともあるため、混乱を避けるためにここでは `publish` にならって「公開」と呼ぶことにしています。

## 継続的統合とは、ソフトウェアの公開プロセスを常に回し続けること

前回までの章で `./gradlew build` コマンドを実行するとコンパイルだけでなく自動テストやそのレポートの作成、配布用ファイルまで行われることを見てきましたが、よく考えれば毎回テストを実行したり配布用ファイルを作ったりする必要は無いはずです。
自動テストはソースコード変更が落ち着いて自動テストを実行したくなったときに、配布用ファイルは配布するときに実行すれば済むのですから。

同じ理由で、コードの変更をこまめにマージする必要もありませんね。
意味のあるまとまりができて始めてマージすればいいのですから。書き途中のコードを他の開発者に見せることは恥ずかしいと感じることもあります。

では `./gradlew build` コマンドを実行するたびにこれらの処理を回すことは無駄なのでしょうか。
コードの変更をこまめにマージすることにはメリットが無いのでしょうか。

### 継続的統合が無い世界の開発プロセスとその問題

継続的統合の価値を考えるための例として、継続的統合をしない世界を考えてみます。
この世界では、以下のような開発が行われるでしょう。

* 手元で変更を溜めておき、意味のある単位でマージする。
    * 例えばRDBのテーブル作成、データベース接続周り、ユーザインタフェース（UI）すべてを一度に更新する。
    * UIが無ければユーザには何の価値も無いと考える。価値提供に注力するため、機能の単位でマージする。
* プロジェクトを公開する締切が近づいてから、配布用ファイルを作成する。
    * プロジェクト公開前にJavadocや配布用ファイルを作るのは計算機資源の無駄。
    * 公開準備が始まってから、配布用ファイル作成の手続きを始めればいい。
* 開発フェーズによってコマンドを使い分ける。
    * 機能開発中でテストが書けていないフェーズでは `./gradlew classes` コマンドを使い、無用なテスト実行を避ける。
    * テストを書いている最中は `./gradlew check` コマンドを使い、自動テストが通ることやカバレッジを確認する。
    * 開発終盤で配布用ファイルの作成をするタイミングで `./gradlew build` コマンドを行い、配布用ファイルを作成する。

実はこうした世界は、以前は一般的に存在しました。特にGitのような分散型バージョン管理システムが普及する前はブランチを新規に作成するコストが高く、またパッチを使ったレビューやマージが主流だったこともあり、継続的に統合をすることが手間でした。

この開発手法は、主に以下のような弊害を引き起こします。

1. 問題を仕込んでから発見するまでの時間が長い。
    * 例えばメソッドを追加したとき、ドキュメンテーションコメントの追加を忘れたとする。
      `javadoc`タスクは`./gradlew classes`コマンドでは実行されないので、開発終盤になるまで発見されない可能性がある。
    * 開発中に後方互換を壊したときに、 `./gradlew classes` コマンドは自動テストを実行していないので発見が遅れる。
2. 時間が経つほどマージが難しくなる。
    * 他の開発者も大きな変更を手元に溜めている。変更同士が衝突をする可能性は高いと考えられる。
      衝突を見つけるのが遅れ、その修正にも時間がかかるので、スケジュールを遅らせる原因になる。
    * 軽快にマージを行うことができなくなり、不具合修正や機能追加が遅れる。
    * 衝突を回避するために、コードを別ファイルにコピペして自分が作っている機能専用のものにするという回避策が横行する。
      コピペされたコードが増えることで品質管理が難しくなり、結果的にプロジェクトの生産性を落とす。
3. コマンドの使い分けは混乱を招く。
    * どういったときにどのようなコマンドを実行するのか、すべてのプロジェクトについて記憶または判断できる人間は多くない。
    * 特に息の長いプロジェクトでは、実行するタスクを最適化する手段を提供するために、コマンドラインオプションが複雑化する傾向にある。Mavenで自動テスト実行をスキップするための `-DskipTests` などが有名。
    * 正しくコマンドを実行できていれば見つかったような問題、つまりケアレスミスが目立つようになる。

計算機資源や一時的な手間を惜しむことで、結局に品質や生産性を損なっていたのです。
こうした反省から生まれたのが継続的統合というベストプラクティスです。

1. 常にコンパイルから公開までのすべてのプロセスを回すことで、問題を早期に発見する。
2. コードを頻繁にマージすることで、手戻りを最小化する。
3. コマンドを単純化する。タスクの最適化は人間ではなくビルドツールにやらせる。

継続的統合とは **計算機資源よりも人間の創造的な時間の方が希少であることを認め、計算機に人間が苦手なことをカバーさせるアプローチ** なのです。

### 何が継続的統合を可能にしたのか

計算機資源がより安価かつ高性能になったことは重要な変化でした。これにより豊富な計算機資源を必要とする自動テストも継続的に行えるようになりました。

また継続的統合のためのシステムや分散型バージョン管理システムがSaaS・PaaSとして提供されたことも、継続的統合の導入や普及を後押ししています。
マージの負担が下がり、より軽快にマージを行うことが普通になり、より小さい単位で変更を共有することが当たり前になりました。

もうひとつ、ビルドツールの進歩も大きな要素だと考えられます。

Apache AntやMavenがJavaプロジェクトにおける主要なビルドツールだった時代は、キャッシュがうまく働かず並列実行も難しかったため、毎回シングルスレッドで最初からビルドをしなおしていました。Mavenはバージョン3になり並列実行を実験的にサポートしていますが、3.0のリリースから10年近く経過した現在でも安定していません^[2020年9月現在、[ドキュメント](https://cwiki.apache.org/confluence/display/MAVEN/Parallel+builds+in+Maven+3)に"So take a little care."と明記されています]。こうした事情から人間が意図的に実行するタスクを最適化する必要性がありました。

現在ではGradleやBazelが生まれ、必要なタスクだけ実行する漸進的（incremental）ビルドや、CPUを使い切るための並行（parallel）ビルドが実行できるようになりました。ビルドの中間結果を複数の開発者で共有し再利用することや、複数の計算機上で分散ビルドも可能です。
ツールが賢くなり、また開発者もタスクの入力と出力とを明示的に扱うようになったので、ツールがビルドの最適化を行うことで人間の負担を減らせたのです。

## まとめ：継続的統合とは、常にソフトウェアの公開のプロセスを回すことでフィードバックを早めること

この章では継続的統合によって、問題を早期に発見できること、変更の衝突や不具合発覚による手戻りを最小化できること、人間がビルドの最適化に注力する必要性を減らせることを学びました。一見不要に見えるソフトウェア公開プロセスを回し続けることで、プロジェクトの品質と生産性を高められることを確認しました。

次の章では継続的統合をプロジェクトで実践する方法について、もっとも始めやすい環境のひとつであるGitHub Actionsを使って学びます。
